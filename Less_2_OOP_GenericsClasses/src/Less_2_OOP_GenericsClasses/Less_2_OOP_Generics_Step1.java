package Less_2_OOP_GenericsClasses;

import Less_2_OOP_GenericsClasses.MySimpleObject.*;

import java.util.ArrayList;
import java.util.List;
/*
Это еще не параметризированные классы, а только подготовка. Намек на то, что было бы неплохо,
иметь в арсенале некий "крутой" класс, который обладая неким полезным функционалом позволял бы
другим самым различным классам использовать свой функционал (некие совершенно волшебные методы)
*/
public class Less_2_OOP_Generics_Step1 {
    public static void main(String[] args) {
        /*
        Так называемый сырой не параметризированный лист, в который мы можем поместить объекты
        наследники Object, а поскольку в Java все объекты наследуются от этого супер-класса, то
        значит наш список мы можем заполнить разношерстной массой.
        */
        List my_row_type = new ArrayList();
        my_row_type.add(5);
        my_row_type.add("Тоже объект");
        my_row_type.add(6.63);
        my_row_type.add(new Planet("Венера", -4.67));
        for (Object my_arr:my_row_type) {
            System.out.println(my_arr);
        }
        /*
        Да! Мы можем хранить разнородные объекты в списке, однако, если мы сами его создали, то
        как-то более-менее можем контролировать степень его использование. А вот если мы приняли
        (получили) нечто подобное извне (и только предполагаем о его содержании) и тут же без
        проверки бросили это в работу, можно нахватать ошибок и исключений.
        Для исключения неоднородности в коллекциях принято их параметризовать, т.е. заранее объявлять
        ссылки на объекты какого класса (или интерфейса) собраны под одной крышей. Что уже на этапе
        компиляции позволяет намекнуть программисту о том, что он пытается например добавить в коллекцию
        слегка не тот объект (например в коллекцию Integer, мы пытаемся поместить String)
        */
        List<Planet> mySolarSystem= new ArrayList<>(); // Коллекция из объектов класса Planet
    }
}
